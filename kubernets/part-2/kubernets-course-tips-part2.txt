PART 2 KUBERNETS: REPLICASETS, VOLUMES E DEPLOYMENTS

##################################################
#   01 - Conhecendo replicasets e deployment
##################################################

ReplicaSet: criar um 'novo' pod, caso algum do cluster morra. Ele não ressuscita o antigo, ele cria um novo em caso de falha. rs
Deployment: uma camada acima do replicaset, automaticamente define um replicaset ao ser criado um deployment. Ele gerencia o versionamento dos pods.

Docs: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/ 

> Listar replicaset: kubectl get replicasets or rs
> Escutar replicaset: kubectl get rs --watch

Obs.: com o serviço ele faz o selector da mesma forma com o replicaset, pois o nome do labels: app é o mesmo. O replicaset substitui o POD, fazendo um conjuto desses em replicas: 
O serviço fará todo o balanceamdno de carga para a quantidade de pods existantes.

#Deployment

Ao criar um deployment, ele cria os pods e o replicaset automaticamente
SERVICE -> DEPLOYMENT( REPLICASETS -> PODS)

VANTAGEM: A grande vantagem do deployment: faz o controle do versionamento dos pods e imagens. Permite criação de tags e msgs, bem como o rollback das imagens
Quando criados, Deployments auxiliam com controle de versionamento e criam um ReplicaSet automaticamente.

Fez um apply no arquivo do depoyment, pode executar os comandos:

kubectl get deployment
kubectl get rs
kubectl get pods

> Ver as revisões:  kubectl rollout history deployment nginx-deployment

> Precisou alterar algo no arquivo deployment.yaml, faze um novo apply com o record (versionamento): kubectl apply -f nginx-deployment.yaml --record 
Ele alterou o campo CHANGE-CAUSE do history e versionou (ver comando a seguir)

> Alterar a msg do campo CHANGE-CAUSE: kubectl.exe annotate deployment nginx-deployment kubernetes.io/change-cause="Definindo a imagem com a versão latest"

> DESCRIBE-IMAGE. Verificar versão do pod que está em execução: kubectl.exe describe pod nginx-deployment-6d8bdc7876-l7nng <POD-NAME> | grep image
Ver output:
Normal  Pulling    11h   kubelet            Pulling image "nginx:1"
Normal  Pulled     11h   kubelet            Successfully pulled image "nginx:1

> Fazer rollback de uma versão:  kubectl.exe rollout undo deployment nginx-deployment <DEPPLOY-NAME> --to-revision=2 <REVISION-ID>
Se fizer um novo describe em um dos pods vc verá a versão alterada (ver comando DESCRIBE-IMAGE

> Delete deployment: 1) kubectl delete deployment nginx-deployment
                     2) kubectl delete -f nginx-deployment.yaml
(Apaga deployment, replicaset e pods)

> Transformar replicaset em deployment: basta copiar todo conteúdo e alterar o 'kind' Deployment  e 'metadata:name' portal-noticias-deployment

Link de acesso: http://localhost:30000

#Volumes de persistência / store classes

O que aprendemos nessa aula:
    A manter pods em execução com ReplicaSets e Deployments através de arquivos declarativos
    A fazer o controle de versionamento de Deployments com o kubectl
    Como utilizar os comandos kubectl rollout para ver e alterar as versões de Deployments.
    Que ReplicaSets são criados automaticamente dentro de um Deployment
    Que Pods normalmente são criados através de Deployments, e não individualmente.
	
##################################################
#  02 - Persistindo dados com volumes
##################################################

>> Resources:
Volumes
Persistent Volumes
Store Class

CICLO DE VIDA VOLUMES: são independentes dos containers, mas dependentes dos pods. 
Isso quer dizer que: se o container falha não impacta, porém se todos os pods morrerem, o volume será excluído, mas os arquivos ficarão no diretório.
Volumes possuem ciclo de vida dependentes de Pods e independentes de containers.
O modo comum de volume, usando inclusive no docker, é o 'hostPath'

VOlumes kubernets reference: https://kubernetes.io/docs/concepts/storage/volumes/

> Entrar no volume do container: kubectl.exe exec -it pod-volume --container nginx-container -- bash
                                 navegar até :/volume-dentro-container e criar um arquivo -> ver que ele criou na pasta do SO do volume: C:\development\WORKSPACES\Labs\kubernets\volumes
> Se der um describe no pod, verá o volume criado: kubectl pod decribe pod-volume -> 'Volumes:' ...